#!/usr/bin/env node

/**
 * AIGNE CodeSmith Release Script (Node.js version)
 * Cross-platform release automation for the GitHub Action
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Configuration
const DIST_DIR = 'dist';
const MAIN_BRANCH = 'master';
const PACKAGE_FILE = 'package.json';

// Colors for console output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m'
};

// Utility functions
function log(message) {
  console.log(`${colors.blue}[INFO]${colors.reset} ${message}`);
}

function success(message) {
  console.log(`${colors.green}[SUCCESS]${colors.reset} ${message}`);
}

function warn(message) {
  console.log(`${colors.yellow}[WARN]${colors.reset} ${message}`);
}

function error(message) {
  console.error(`${colors.red}[ERROR]${colors.reset} ${message}`);
  process.exit(1);
}

function execCommand(command, options = {}) {
  try {
    return execSync(command, { 
      encoding: 'utf8', 
      stdio: options.silent ? 'pipe' : 'inherit',
      ...options 
    });
  } catch (err) {
    if (!options.allowFail) {
      error(`Command failed: ${command}\n${err.message}`);
    }
    throw err;
  }
}

// Check dependencies
function checkDependencies() {
  const deps = [
    { cmd: 'node --version', name: 'Node.js' },
    { cmd: 'npm --version', name: 'npm' },
    { cmd: 'git --version', name: 'Git' },
    { cmd: 'gh --version', name: 'GitHub CLI' }
  ];

  for (const dep of deps) {
    try {
      execCommand(dep.cmd, { silent: true });
    } catch {
      error(`${dep.name} is required but not installed.`);
    }
  }
}

// Check if we're on the main branch
function checkBranch() {
  const currentBranch = execCommand('git branch --show-current', { silent: true }).trim();
  if (currentBranch !== MAIN_BRANCH) {
    error(`Must be on ${MAIN_BRANCH} branch to create a release. Current branch: ${currentBranch}`);
  }
}

// Check if working directory is clean
function checkCleanWorkingDir() {
  try {
    const status = execCommand('git status --porcelain', { silent: true });
    if (status.trim()) {
      error('Working directory is not clean. Please commit or stash your changes.');
    }
  } catch {
    error('Failed to check git status');
  }
}

// Get current version from package.json
function getCurrentVersion() {
  const packageJson = JSON.parse(fs.readFileSync(PACKAGE_FILE, 'utf8'));
  return packageJson.version;
}

// Update version in package.json
function updatePackageVersion(newVersion) {
  const packageJson = JSON.parse(fs.readFileSync(PACKAGE_FILE, 'utf8'));
  packageJson.version = newVersion;
  fs.writeFileSync(PACKAGE_FILE, JSON.stringify(packageJson, null, 2) + '\n');
  success(`Updated package.json version to ${newVersion}`);
}

// Validate semantic version format
function validateVersion(version) {
  const semverRegex = /^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*)?$/;
  if (!semverRegex.test(version)) {
    error(`Invalid version format: ${version}. Use semantic versioning (e.g., 1.0.0, 1.0.0-beta.1)`);
  }
}

// Generate changelog
function generateChangelog(version) {
  let previousTag = '';
  try {
    previousTag = execCommand('git describe --tags --abbrev=0', { silent: true, allowFail: true }).trim();
  } catch {
    // No previous tags
  }

  const date = new Date().toISOString().split('T')[0];
  let changelog = `## [${version}] - ${date}\n\n`;

  if (previousTag) {
    changelog += `### Changes since ${previousTag}\n\n`;
    try {
      const commits = execCommand(`git log --oneline --pretty=format:"- %s" ${previousTag}..HEAD`, { silent: true });
      const filteredCommits = commits
        .split('\n')
        .filter(line => line && !line.includes('Merge') && !line.includes('chore: rebuild release'))
        .join('\n');
      changelog += filteredCommits || '- No significant changes';
    } catch {
      changelog += '- Unable to generate change list';
    }
  } else {
    changelog += '### Initial Release\n\n- Initial release of AIGNE CodeSmith GitHub Action';
  }

  return changelog;
}

// Build and bundle the action
async function buildAction() {
  log('Building TypeScript sources...');
  execCommand('npm run build');

  log('Bundling with ncc...');
  execCommand('npm run package');

  log('Running linting...');
  execCommand('npm run lint');

  log('Running formatting check...');
  execCommand('npm run format-check');

  success('Build completed successfully');
}

// Commit release changes
function commitRelease(version) {
  execCommand(`git add ${PACKAGE_FILE} ${DIST_DIR}/`);
  
  const commitMessage = `chore: release v${version}

- Update version to ${version}
- Rebuild distribution files
- Generated by release script

ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>`;

  execCommand(`git commit -m "${commitMessage}"`);
  success(`Committed release changes for v${version}`);
}

// Create and push git tag
function createTag(version) {
  const tag = `v${version}`;
  const changelog = generateChangelog(version);
  
  // Write changelog to temp file for multiline tag message
  const tempFile = path.join(__dirname, 'temp-changelog.md');
  fs.writeFileSync(tempFile, `Release ${tag}\n\n${changelog}`);
  
  try {
    execCommand(`git tag -a ${tag} -F ${tempFile}`);
    execCommand(`git push origin ${MAIN_BRANCH} --tags`);
    success(`Created and pushed tag ${tag}`);
  } finally {
    // Clean up temp file
    if (fs.existsSync(tempFile)) {
      fs.unlinkSync(tempFile);
    }
  }
}

// Create GitHub release
function createGitHubRelease(version) {
  const tag = `v${version}`;
  const changelog = generateChangelog(version);
  
  // Write changelog to temp file
  const tempFile = path.join(__dirname, 'temp-release-notes.md');
  fs.writeFileSync(tempFile, changelog);
  
  try {
    log(`Creating GitHub release for ${tag}...`);
    execCommand(`gh release create ${tag} --title "AIGNE CodeSmith ${tag}" --notes-file ${tempFile} --latest`);
    success(`Created GitHub release ${tag}`);
  } finally {
    // Clean up temp file
    if (fs.existsSync(tempFile)) {
      fs.unlinkSync(tempFile);
    }
  }
}

// Update major version tag
function updateMajorTag(version) {
  const majorVersion = `v${version.split('.')[0]}`;
  
  log(`Updating major version tag ${majorVersion}...`);
  
  // Delete existing major tag locally and remotely
  try {
    execCommand(`git tag -d ${majorVersion}`, { silent: true, allowFail: true });
  } catch {}
  try {
    execCommand(`git push origin :refs/tags/${majorVersion}`, { silent: true, allowFail: true });
  } catch {}
  
  // Create new major tag
  execCommand(`git tag -a ${majorVersion} -m "Release ${majorVersion} (latest: v${version})"`);
  execCommand(`git push origin ${majorVersion} --force`);
  
  success(`Updated major version tag ${majorVersion}`);
}

// Prompt user for confirmation
function askForConfirmation(question) {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.toLowerCase().startsWith('y'));
    });
  });
}

// Calculate next version based on release type
function calculateNextVersion(currentVersion, releaseType) {
  const parts = currentVersion.split('.').map(Number);
  
  switch (releaseType) {
    case 'major':
      return `${parts[0] + 1}.0.0`;
    case 'minor':
      return `${parts[0]}.${parts[1] + 1}.0`;
    case 'patch':
      return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;
    default:
      error(`Invalid release type: ${releaseType}`);
  }
}

// Main release function
async function main() {
  const [,, releaseType, customVersion] = process.argv;
  
  log('ðŸš€ Starting AIGNE CodeSmith release process...');
  
  // Pre-flight checks
  checkDependencies();
  checkBranch();
  checkCleanWorkingDir();
  
  // Get current version
  const currentVersion = getCurrentVersion();
  log(`Current version: ${currentVersion}`);
  
  // Determine new version
  let newVersion;
  if (customVersion) {
    newVersion = customVersion;
    validateVersion(newVersion);
  } else if (['major', 'minor', 'patch'].includes(releaseType)) {
    newVersion = calculateNextVersion(currentVersion, releaseType);
  } else {
    error(`Usage: node scripts/release.js <major|minor|patch> [custom-version]
    
Examples:
  node scripts/release.js patch                 # ${currentVersion} -> ${calculateNextVersion(currentVersion, 'patch')}
  node scripts/release.js minor                 # ${currentVersion} -> ${calculateNextVersion(currentVersion, 'minor')}
  node scripts/release.js major                 # ${currentVersion} -> ${calculateNextVersion(currentVersion, 'major')}
  node scripts/release.js custom 1.5.0-beta.1  # Set specific version`);
  }
  
  log(`New version will be: ${newVersion}`);
  
  // Confirm with user
  const confirmed = await askForConfirmation(`Proceed with release v${newVersion}? [y/N]: `);
  if (!confirmed) {
    error('Release cancelled by user');
  }
  
  try {
    // Update version
    updatePackageVersion(newVersion);
    
    // Build and test
    await buildAction();
    
    // Create release commit and tag
    commitRelease(newVersion);
    createTag(newVersion);
    
    // Create GitHub release
    createGitHubRelease(newVersion);
    
    // Update major version tag
    updateMajorTag(newVersion);
    
    success('ðŸŽ‰ Release v' + newVersion + ' completed successfully!');
    
    // Get repository info for next steps
    const repoUrl = execCommand('git config --get remote.origin.url', { silent: true }).trim();
    const repoPath = repoUrl.replace(/.*github\.com[/:](.*?)(?:\.git)?$/, '$1');
    
    log('\nNext steps:');
    log(`  1. Verify the release at: https://github.com/${repoPath}/releases/tag/v${newVersion}`);
    log(`  2. Test the action in a repository using: ${repoPath}@v${newVersion}`);
    log('  3. Update any documentation that references version numbers');
    
  } catch (err) {
    error(`Release failed: ${err.message}`);
  }
}

// Handle process termination
process.on('SIGINT', () => {
  console.log('\n\nRelease process interrupted by user');
  process.exit(1);
});

process.on('uncaughtException', (err) => {
  error(`Unexpected error: ${err.message}`);
});

// Run the main function
if (require.main === module) {
  main().catch(err => {
    error(`Release failed: ${err.message}`);
  });
}